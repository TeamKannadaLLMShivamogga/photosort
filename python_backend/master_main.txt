
import os
import shutil
import uuid
from datetime import datetime
from typing import List, Optional, Literal, Set, Union, Any, Dict
from contextlib import asynccontextmanager
from pathlib import Path

from fastapi import FastAPI, HTTPException, Body, BackgroundTasks, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field, BeforeValidator, ConfigDict, field_validator
from motor.motor_asyncio import AsyncIOMotorClient
from bson import ObjectId
from typing_extensions import Annotated
import httpx
from dotenv import load_dotenv

load_dotenv()

# --- Database Setup ---
MONGO_URL = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
DB_NAME = "photosort"
AI_SERVICE_URL = os.getenv("AI_SERVICE_URL", "http://localhost:8001")

client = AsyncIOMotorClient(MONGO_URL)
db = client[DB_NAME]

# --- Static File Setup ---
UPLOAD_DIR = Path("uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# --- Pydantic ObjectId Helper ---
PyObjectId = Annotated[str, BeforeValidator(str)]

class MongoBaseModel(BaseModel):
    id: Optional[PyObjectId] = Field(alias="_id", default=None)
    model_config = ConfigDict(
        populate_by_name=True,
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )

# --- Models ---
UserRole = Literal['ADMIN', 'PHOTOGRAPHER', 'USER']
SubscriptionTier = Literal['FREE', 'PRO', 'STUDIO']
EventStatus = Literal['active', 'completed', 'closed']
PhotoQuality = Literal['high', 'medium', 'low']
EventPlan = Literal['BASIC', 'STANDARD', 'PRO']
PaymentStatus = Literal['pending', 'partial', 'paid']
OptimizationType = Literal['none', 'balanced', 'performance', 'high-quality']
SelectionStatus = Literal['open', 'submitted', 'editing', 'review', 'accepted']
PhotoReviewStatus = Literal['pending', 'approved', 'changes_requested']

class Comment(BaseModel):
    id: str
    author: str
    text: str
    date: datetime
    role: UserRole
    resolved: bool = False

class EventTimeline(BaseModel):
    selectionDeadline: Optional[datetime] = None
    selectionSubmittedAt: Optional[datetime] = None
    editingStartedAt: Optional[datetime] = None
    deliveryEstimate: Optional[datetime] = None
    reviewStartedAt: Optional[datetime] = None
    finalizedAt: Optional[datetime] = None

class FamilyMember(BaseModel):
    id: str
    name: str
    relation: str
    referencePhoto: Optional[str] = None

class SubEvent(BaseModel):
    id: str
    name: str
    date: datetime
    endDate: Optional[datetime] = None

class User(MongoBaseModel):
    email: str
    name: str
    phone: Optional[str] = None
    role: UserRole = 'USER'
    avatar: Optional[str] = None
    familyMembers: List[FamilyMember] = []
    subscriptionTier: SubscriptionTier = 'FREE'
    subscriptionExpiry: Optional[datetime] = None
    isActive: bool = True
    joinDate: Optional[datetime] = Field(default_factory=datetime.now)
    totalEventsCount: int = 0
    totalPhotosCount: int = 0
    totalUsersCount: int = 0

class Event(MongoBaseModel):
    name: str
    date: datetime
    photographerId: str
    coverImage: str
    photoCount: int = 0
    assignedUsers: List[str] = []
    subEvents: List[SubEvent] = []
    status: EventStatus = 'active'
    selectionStatus: SelectionStatus = 'open'
    timeline: EventTimeline = Field(default_factory=EventTimeline)
    price: Optional[float] = 0.0
    paidAmount: Optional[float] = 0.0
    paymentStatus: PaymentStatus = 'pending'
    plan: EventPlan = 'BASIC'
    clientEmail: Optional[str] = None
    clientPhone: Optional[str] = None
    serviceFee: Optional[float] = 0.0
    deadline: Optional[datetime] = None
    optimizationSetting: OptimizationType = 'balanced'

class Photo(MongoBaseModel):
    url: str
    editedUrl: Optional[str] = None
    originalFilename: Optional[str] = None
    eventId: str
    subEventId: Optional[str] = None
    tags: List[str] = []
    people: List[str] = []
    isAiPick: bool = False
    quality: PhotoQuality = 'medium'
    category: Optional[str] = None
    isSelected: bool = False
    reviewStatus: PhotoReviewStatus = 'pending'
    comments: List[Comment] = []
    isAiProcessed: bool = False
    originalSize: Optional[int] = 0
    optimizedSize: Optional[int] = 0
    aiAnalysis: Optional[Dict[str, Any]] = None

    @field_validator('quality', mode='before')
    def parse_quality(cls, v):
        if isinstance(v, dict):
            if v.get('sharp_subject') is True and not v.get('blurry'):
                return 'high'
            return 'medium'
        return v

class LoginRequest(BaseModel):
    email: str

class PaymentRequest(BaseModel):
    amount: float
    date: Optional[datetime] = None

class ClientInfo(BaseModel):
    name: str
    email: str
    phone: Optional[str] = None

class CreateEventRequest(Event):
    initialClients: List[ClientInfo] = []

class AssignUserRequest(BaseModel):
    name: str
    email: str
    phone: Optional[str] = None

class RemoveUserRequest(BaseModel):
    userId: str

class WorkflowUpdate(BaseModel):
    status: SelectionStatus
    deliveryEstimate: Optional[datetime] = None
    note: Optional[str] = None

class CommentInput(BaseModel):
    author: str
    text: str
    role: UserRole

class ReviewStatusUpdate(BaseModel):
    status: PhotoReviewStatus

# --- Startup/Seeding ---
async def seed_data():
    if await db.users.count_documents({}) > 0:
        return
    # Seeding logic is same as before
    pass

@asynccontextmanager
async def lifespan(app: FastAPI):
    await seed_data()
    yield

app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")

# --- Helpers ---
async def trigger_ai_service(event_id: str):
    async with httpx.AsyncClient() as client:
        try:
            await client.post(f"{AI_SERVICE_URL}/process-event/{event_id}")
        except Exception as e:
            print(f"Failed to trigger AI service: {e}")

async def resolve_and_create_user(name: str, email: str, phone: Optional[str] = None) -> str:
    query = {"email": email}
    if phone:
        query = {"$or": [{"email": email}, {"phone": phone}]}
    existing_user = await db.users.find_one(query)
    if existing_user:
        return str(existing_user["_id"])
    new_user = User(email=email, name=name, phone=phone, role="USER", avatar=f"https://ui-avatars.com/api/?name={name}&background=random")
    result = await db.users.insert_one(new_user.model_dump(by_alias=True, exclude=["id"]))
    return str(result.inserted_id)

# --- Routes ---
@app.get("/")
def read_root():
    return {"status": "Master Backend Running"}

# ... (Previous Auth, User, Event Routes kept as is) ...

@app.post("/api/auth/login", response_model=User)
async def login(req: LoginRequest):
    user = await db.users.find_one({"email": req.email})
    if not user:
        new_user = User(
            email=req.email,
            name=req.email.split('@')[0],
            role="USER",
            avatar=f"https://ui-avatars.com/api/?name={req.email}&background=random"
        )
        res = await db.users.insert_one(new_user.model_dump(by_alias=True, exclude=["id"]))
        created_user = await db.users.find_one({"_id": res.inserted_id})
        return created_user
    return user

@app.get("/api/users", response_model=List[User])
async def get_users():
    return await db.users.find().to_list(1000)

@app.post("/api/users", response_model=User)
async def create_user(user: User):
    new_user = await db.users.insert_one(user.model_dump(by_alias=True, exclude=["id"]))
    return await db.users.find_one({"_id": new_user.inserted_id})

@app.put("/api/users/{id}", response_model=User)
async def update_user(id: str, user: User):
    await db.users.update_one({"_id": ObjectId(id)}, {"$set": user.model_dump(exclude=["id"])})
    return await db.users.find_one({"_id": ObjectId(id)})

@app.delete("/api/users/{id}")
async def delete_user(id: str):
    await db.users.delete_one({"_id": ObjectId(id)})
    return {"message": "User deleted"}

@app.patch("/api/users/{id}/status", response_model=User)
async def toggle_user_status(id: str):
    user = await db.users.find_one({"_id": ObjectId(id)})
    if not user: raise HTTPException(status_code=404, detail="User not found")
    new_status = not user.get("isActive", True)
    await db.users.update_one({"_id": ObjectId(id)}, {"$set": {"isActive": new_status}})
    return await db.users.find_one({"_id": ObjectId(id)})

@app.get("/api/events", response_model=List[Event])
async def get_events():
    return await db.events.find().to_list(1000)

@app.post("/api/events", response_model=Event)
async def create_event(payload: CreateEventRequest):
    event_dict = payload.model_dump(by_alias=True, exclude=["id", "initialClients"])
    assigned_ids = []
    if payload.initialClients:
        for client in payload.initialClients:
            uid = await resolve_and_create_user(client.name, client.email, client.phone)
            assigned_ids.append(uid)
    event_dict["assignedUsers"] = list(set(event_dict.get("assignedUsers", []) + assigned_ids))
    if not event_dict.get("subEvents"):
         event_dict["subEvents"] = [SubEvent(id=f"se-{datetime.now().timestamp()}", name="Main Event", date=payload.date).model_dump()]
    new_event = await db.events.insert_one(event_dict)
    return await db.events.find_one({"_id": new_event.inserted_id})

@app.put("/api/events/{id}", response_model=Event)
async def update_event(id: str, event: Event):
    await db.events.update_one({"_id": ObjectId(id)}, {"$set": event.model_dump(exclude=["id"])})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.delete("/api/events/{id}")
async def delete_event(id: str):
    await db.events.delete_one({"_id": ObjectId(id)})
    await db.photos.delete_many({"eventId": id})
    return {"message": "Event deleted"}

@app.post("/api/events/{id}/assign-user", response_model=Event)
async def assign_user_to_event(id: str, payload: AssignUserRequest):
    user_id = await resolve_and_create_user(payload.name, payload.email, payload.phone)
    await db.events.update_one({"_id": ObjectId(id)}, {"$addToSet": {"assignedUsers": user_id}})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.post("/api/events/{id}/remove-user", response_model=Event)
async def remove_user_from_event(id: str, payload: RemoveUserRequest):
    await db.events.update_one({"_id": ObjectId(id)}, {"$pull": {"assignedUsers": payload.userId}})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.post("/api/events/{id}/subevents", response_model=Event)
async def add_sub_event(id: str, sub_event: SubEvent):
    sub_event_dict = sub_event.model_dump()
    if not sub_event_dict.get("id"): sub_event_dict["id"] = f"se-{datetime.now().timestamp()}"
    await db.events.update_one({"_id": ObjectId(id)}, {"$push": {"subEvents": sub_event_dict}})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.patch("/api/events/{id}/workflow", response_model=Event)
async def update_workflow(id: str, payload: WorkflowUpdate):
    updates = {"selectionStatus": payload.status}
    now = datetime.now()
    timeline_updates = {}
    if payload.status == 'submitted': timeline_updates["timeline.selectionSubmittedAt"] = now
    elif payload.status == 'editing': timeline_updates["timeline.editingStartedAt"] = now
    elif payload.status == 'review': timeline_updates["timeline.reviewStartedAt"] = now
    elif payload.status == 'accepted': timeline_updates["timeline.finalizedAt"] = now
    if payload.deliveryEstimate: timeline_updates["timeline.deliveryEstimate"] = payload.deliveryEstimate
    if timeline_updates: updates.update(timeline_updates)
    await db.events.update_one({"_id": ObjectId(id)}, {"$set": updates})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.post("/api/events/{id}/payment", response_model=Event)
async def record_payment(id: str, payload: PaymentRequest):
    event = await db.events.find_one({"_id": ObjectId(id)})
    if not event: raise HTTPException(status_code=404, detail="Event not found")
    new_paid = (event.get("paidAmount") or 0) + payload.amount
    total = event.get("price") or 0
    status = "paid" if new_paid >= total and total > 0 else ("partial" if new_paid > 0 else "pending")
    await db.events.update_one({"_id": ObjectId(id)}, {"$set": {"paidAmount": new_paid, "paymentStatus": status}})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.get("/api/events/{id}/photos", response_model=List[Photo])
async def get_event_photos(id: str):
    return await db.photos.find({"eventId": id}).to_list(2000)

@app.post("/api/events/{id}/photos", response_model=List[Photo])
async def upload_photos(id: str, subEventId: Optional[str] = Form(None), files: List[UploadFile] = File(...), background_tasks: BackgroundTasks = None):
    saved = []
    event_dir = UPLOAD_DIR / id
    event_dir.mkdir(parents=True, exist_ok=True)
    for file in files:
        ext = os.path.splitext(file.filename)[1] or ".jpg"
        fname = f"{uuid.uuid4()}{ext}"
        fpath = event_dir / fname
        content = await file.read()
        with open(fpath, "wb") as f: f.write(content)
        url = f"/uploads/{id}/{fname}"
        saved.append({
            "url": url, 
            "eventId": id, 
            "subEventId": subEventId, 
            "tags": [], 
            "people": [],
            "isAiPick": False, 
            "quality": "medium", 
            "isSelected": False, 
            "isAiProcessed": False,
            "originalSize": len(content), 
            "optimizedSize": 0,
            "originalFilename": file.filename # Save original filename
        })
    if not saved: return []
    res = await db.photos.insert_many(saved)
    count = await db.photos.count_documents({"eventId": id})
    await db.events.update_one({"_id": ObjectId(id)}, {"$set": {"photoCount": count}})
    if background_tasks: background_tasks.add_task(trigger_ai_service, id)
    return await db.photos.find({"_id": {"$in": res.inserted_ids}}).to_list(None)

@app.post("/api/events/{id}/photos/bulk-edit", response_model=List[Photo])
async def bulk_upload_edits(id: str, files: List[UploadFile] = File(...)):
    """
    Matches uploaded edited files to original photos by originalFilename.
    """
    event_dir = UPLOAD_DIR / id
    event_dir.mkdir(parents=True, exist_ok=True)
    
    updated_photos = []
    
    # 1. Fetch all photos for this event that are selected or candidates for editing
    #    (or all photos to be safe)
    cursor = db.photos.find({"eventId": id}, {"_id": 1, "originalFilename": 1})
    photos_map = {doc["originalFilename"]: doc["_id"] for doc in await cursor.to_list(None) if doc.get("originalFilename")}
    
    for file in files:
        # Match logic: Exact filename match
        if file.filename in photos_map:
            photo_id = photos_map[file.filename]
            
            # Save file
            ext = os.path.splitext(file.filename)[1] or ".jpg"
            fname = f"edit_{uuid.uuid4()}{ext}"
            fpath = event_dir / fname
            
            content = await file.read()
            with open(fpath, "wb") as f: f.write(content)
            
            edited_url = f"/uploads/{id}/{fname}"
            
            # Update DB
            await db.photos.update_one(
                {"_id": photo_id},
                {"$set": {"editedUrl": edited_url}}
            )
            updated_photos.append(photo_id)
            
    # Return updated photos
    if not updated_photos:
        return []
        
    return await db.photos.find({"_id": {"$in": updated_photos}}).to_list(None)

@app.post("/api/photos/{id}/edit", response_model=Photo)
async def upload_edited_photo(id: str, file: UploadFile = File(...)):
    photo = await db.photos.find_one({"_id": ObjectId(id)})
    if not photo: raise HTTPException(status_code=404, detail="Photo not found")
    event_dir = UPLOAD_DIR / photo["eventId"]
    event_dir.mkdir(parents=True, exist_ok=True)
    fname = f"edit_{uuid.uuid4()}{os.path.splitext(file.filename)[1] or '.jpg'}"
    with open(event_dir / fname, "wb") as f: f.write(await file.read())
    url = f"/uploads/{photo['eventId']}/{fname}"
    await db.photos.update_one({"_id": ObjectId(id)}, {"$set": {"editedUrl": url}})
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.post("/api/photos/{id}/comment", response_model=Photo)
async def add_comment(id: str, comment: CommentInput):
    new_comment = {"id": str(uuid.uuid4()), "date": datetime.now(), **comment.model_dump(), "resolved": False}
    await db.photos.update_one({"_id": ObjectId(id)}, {"$push": {"comments": new_comment}})
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.post("/api/photos/{id}/comments/{comment_id}/resolve", response_model=Photo)
async def resolve_comment(id: str, comment_id: str):
    await db.photos.update_one(
        {"_id": ObjectId(id), "comments.id": comment_id},
        {"$set": {"comments.$.resolved": True}}
    )
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.post("/api/photos/{id}/review-status", response_model=Photo)
async def update_review_status(id: str, payload: ReviewStatusUpdate):
    await db.photos.update_one({"_id": ObjectId(id)}, {"$set": {"reviewStatus": payload.status}})
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.post("/api/photos/{id}/selection", response_model=Photo)
async def toggle_selection(id: str):
    photo = await db.photos.find_one({"_id": ObjectId(id)})
    new_val = not photo.get("isSelected", False)
    await db.photos.update_one({"_id": ObjectId(id)}, {"$set": {"isSelected": new_val}})
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.post("/api/events/{id}/approve-all")
async def approve_all_edits(id: str):
    # Approve all photos that have an editedUrl
    await db.photos.update_many(
        {"eventId": id, "editedUrl": {"$exists": True, "$ne": None}},
        {"$set": {"reviewStatus": "approved"}}
    )
    # Automatically update workflow to 'accepted' if in review
    await db.events.update_one(
        {"_id": ObjectId(id), "selectionStatus": "review"},
        {"$set": {"selectionStatus": "accepted", "timeline.finalizedAt": datetime.now()}}
    )
    return {"message": "All edits approved"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
