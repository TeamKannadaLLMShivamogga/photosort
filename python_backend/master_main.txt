
import os
import shutil
import time
import json
from datetime import datetime
from typing import List, Optional, Literal, Dict, Any
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException, Body, BackgroundTasks, UploadFile, File, Form, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field, BeforeValidator, ConfigDict, EmailStr
from motor.motor_asyncio import AsyncIOMotorClient
from bson import ObjectId
from typing_extensions import Annotated
import httpx
from dotenv import load_dotenv

load_dotenv()

# --- Database & Config ---
MONGO_URL = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
DB_NAME = "photosort"
# Updated AI Service Port to 8011
AI_SERVICE_URL = os.getenv("AI_SERVICE_URL", "http://localhost:8011")
UPLOAD_DIR = "uploads"

# CRITICAL FIX: Ensure directory exists BEFORE app.mount is called
try:
    os.makedirs(UPLOAD_DIR, exist_ok=True)
    print(f"Created/Verified upload directory at: {os.path.abspath(UPLOAD_DIR)}")
except Exception as e:
    print(f"Error creating upload directory: {e}")

client = AsyncIOMotorClient(MONGO_URL)
db = client[DB_NAME]

# --- Pydantic Helpers ---
PyObjectId = Annotated[str, BeforeValidator(str)]

class MongoBaseModel(BaseModel):
    id: Optional[PyObjectId] = Field(alias="_id", default=None)
    model_config = ConfigDict(
        populate_by_name=True,
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )

# --- Domain Models ---

UserRole = Literal['ADMIN', 'PHOTOGRAPHER', 'USER']
EventStatus = Literal['active', 'completed', 'closed']
SelectionStatus = Literal['open', 'submitted', 'editing', 'review', 'accepted']
EventTeamRole = Literal['CO_ADMIN', 'MEMBER']

class Service(BaseModel):
    id: str
    name: str
    price: float
    type: str = 'service'
    description: Optional[str] = None

class Portfolio(BaseModel):
    bio: str = ""
    galleryImages: List[str] = []
    videoLinks: List[str] = []

class FamilyMember(BaseModel):
    id: str
    name: str
    relation: str
    referencePhoto: Optional[str] = None

class SubEvent(BaseModel):
    id: str
    name: str
    date: datetime
    location: Optional[str] = None

class PaymentRecord(BaseModel):
    id: str
    date: datetime
    amount: float
    method: str
    note: Optional[str] = None

class EventTimeline(BaseModel):
    selectionDeadline: Optional[datetime] = None
    deliveryEstimate: Optional[datetime] = None
    selectionSubmittedAt: Optional[datetime] = None
    editingStartedAt: Optional[datetime] = None
    reviewStartedAt: Optional[datetime] = None
    finalizedAt: Optional[datetime] = None

class EventTeamMember(BaseModel):
    userId: str
    role: EventTeamRole = 'MEMBER'

class User(MongoBaseModel):
    email: EmailStr
    name: str
    role: UserRole = 'USER'
    phone: Optional[str] = None
    avatar: Optional[str] = None
    familyMembers: List[FamilyMember] = []
    subscriptionTier: str = 'FREE'
    subscriptionExpiry: Optional[datetime] = None
    isActive: bool = True
    joinDate: datetime = Field(default_factory=datetime.now)
    services: List[Service] = []
    portfolio: Portfolio = Field(default_factory=Portfolio)
    # Stats
    totalEventsCount: int = 0
    totalPhotosCount: int = 0
    totalUsersCount: int = 0

class Event(MongoBaseModel):
    name: str
    date: datetime
    endDate: Optional[datetime] = None
    location: Optional[str] = None
    photographerId: str
    coverImage: str
    photoCount: int = 0
    assignedUsers: List[str] = []
    team: List[EventTeamMember] = [] 
    subEvents: List[SubEvent] = []
    status: EventStatus = 'active'
    selectionStatus: SelectionStatus = 'open'
    timeline: EventTimeline = Field(default_factory=EventTimeline)
    price: float = 0.0
    paidAmount: float = 0.0
    paymentStatus: str = 'pending'
    paymentHistory: List[PaymentRecord] = []
    plan: str = 'BASIC'
    clientEmail: Optional[str] = None
    clientPhone: Optional[str] = None
    serviceFee: float = 0.0
    optimizationSetting: str = 'balanced'
    selectedServices: List[Service] = []
    # Virtual field for creation
    initialClients: Optional[List[Dict[str, str]]] = None 

class Comment(BaseModel):
    id: str
    author: str
    text: str
    date: datetime
    role: str
    resolved: bool = False

class Photo(MongoBaseModel):
    url: str
    eventId: str
    subEventId: Optional[str] = None
    originalFilename: Optional[str] = None
    tags: List[str] = []
    people: List[str] = []
    isAiPick: bool = False
    quality: str = 'medium'
    category: Optional[str] = "General"
    isSelected: bool = False
    reviewStatus: str = 'pending'
    editedUrl: Optional[str] = None
    isAiProcessed: bool = False
    comments: List[Comment] = []

# --- DTOs ---
class LoginRequest(BaseModel):
    email: str

class SignupRequest(BaseModel):
    name: str
    email: str
    phone: str
    role: UserRole = 'PHOTOGRAPHER'

class PhotoUploadRequest(BaseModel):
    photos: List[Photo]

class PaymentRequest(BaseModel):
    amount: float
    date: str
    method: str
    note: Optional[str] = None

class AddTeamMemberRequest(BaseModel):
    email: str
    role: EventTeamRole

# --- Lifecycle ---

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Ensure upload directory (Redundant check but good for safety)
    os.makedirs(UPLOAD_DIR, exist_ok=True)
    
    # Simple Seed check
    if await db.users.count_documents({}) == 0:
        await seed_database()
    yield

async def seed_database():
    print("Seeding Initial Data...")
    # Admin
    await db.users.insert_one(User(
        name="System Admin", email="admin@photosort.com", role="ADMIN", 
        avatar="https://ui-avatars.com/api/?name=Admin&background=000&color=fff"
    ).model_dump(by_alias=True, exclude=["id"]))
    
    # Photographer
    await db.users.insert_one(User(
        name="Demo Studio", email="photographer@photosort.com", role="PHOTOGRAPHER",
        subscriptionTier="PRO", avatar="https://ui-avatars.com/api/?name=Demo+Studio&background=10B981&color=fff"
    ).model_dump(by_alias=True, exclude=["id"]))

    # Client
    await db.users.insert_one(User(
        name="Rohan & Priya", email="user@photosort.com", role="USER",
        avatar="https://ui-avatars.com/api/?name=Rohan+Priya&background=random"
    ).model_dump(by_alias=True, exclude=["id"]))
    print("Seeding Complete.")

app = FastAPI(lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Static Files
app.mount("/uploads", StaticFiles(directory=UPLOAD_DIR), name="uploads")

# --- Helpers ---

async def trigger_ai_service(event_id: str):
    """Fire and forget call to AI service"""
    async with httpx.AsyncClient() as client:
        try:
            # Short timeout, we don't wait for completion
            await client.post(f"{AI_SERVICE_URL}/process-event/{event_id}", timeout=1.0)
        except Exception as e:
            print(f"Triggered AI Service (Background): {e}")

# --- Routes ---

@app.get("/")
def read_root():
    return {"status": "Master Backend Online (Port 8010)", "docs": "/docs"}

# --- Auth ---

@app.post("/api/auth/login", response_model=User)
async def login(req: LoginRequest):
    user = await db.users.find_one({"email": req.email})
    if not user:
        # Auto-create for demo/client ease
        new_user = User(
            email=req.email,
            name=req.email.split("@")[0],
            role='USER',
            avatar=f"https://ui-avatars.com/api/?name={req.email}&background=random"
        )
        res = await db.users.insert_one(new_user.model_dump(by_alias=True, exclude=["id"]))
        return await db.users.find_one({"_id": res.inserted_id})
    return user

@app.post("/api/auth/signup", response_model=User)
async def signup(req: SignupRequest):
    existing = await db.users.find_one({"email": req.email})
    if existing:
        return existing # In real app, return error or handle properly
    
    new_user = User(
        email=req.email, name=req.name, phone=req.phone, role=req.role,
        avatar=f"https://ui-avatars.com/api/?name={req.name}&background=random"
    )
    res = await db.users.insert_one(new_user.model_dump(by_alias=True, exclude=["id"]))
    return await db.users.find_one({"_id": res.inserted_id})

# --- Uploads ---

@app.post("/api/upload")
async def upload_general_file(file: UploadFile = File(...)):
    filename = f"general_{int(time.time())}_{file.filename}"
    path = os.path.join(UPLOAD_DIR, filename)
    
    with open(path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
        
    return {"url": f"/uploads/{filename}"}

@app.post("/api/events/{id}/upload")
async def upload_event_file(id: str, file: UploadFile = File(...)):
    # Create subfolder for organization (optional, keeping flat for simplicity here)
    filename = f"evt_{id}_{int(time.time())}_{file.filename}"
    path = os.path.join(UPLOAD_DIR, filename)
    
    with open(path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
        
    return {"url": f"/uploads/{filename}", "originalFilename": file.filename}

# --- Users ---

@app.get("/api/users", response_model=List[User])
async def get_users():
    return await db.users.find().to_list(1000)

@app.put("/api/users/{id}", response_model=User)
async def update_user(id: str, updates: dict = Body(...)):
    # Security check omitted for demo
    if '_id' in updates: del updates['_id']
    await db.users.update_one({"_id": ObjectId(id)}, {"$set": updates})
    return await db.users.find_one({"_id": ObjectId(id)})

@app.patch("/api/users/{id}/status")
async def toggle_user_status(id: str):
    user = await db.users.find_one({"_id": ObjectId(id)})
    if user:
        await db.users.update_one({"_id": ObjectId(id)}, {"$set": {"isActive": not user.get("isActive", True)}})
    return await db.users.find_one({"_id": ObjectId(id)})

# --- Events ---

@app.get("/api/events", response_model=List[Event])
async def get_events():
    return await db.events.find().sort("date", -1).to_list(1000)

@app.post("/api/events", response_model=Event)
async def create_event(event: Event):
    event_data = event.model_dump(by_alias=True, exclude=["id", "initialClients"])
    
    # 1. Handle Clients
    assigned_ids = []
    if event.initialClients:
        for client_info in event.initialClients:
            # Check if exists
            existing = await db.users.find_one({"email": client_info['email']})
            if existing:
                assigned_ids.append(str(existing["_id"]))
            else:
                # Create
                new_client = User(
                    name=client_info['name'], 
                    email=client_info['email'], 
                    phone=client_info.get('phone'),
                    role='USER',
                    avatar=f"https://ui-avatars.com/api/?name={client_info['name']}"
                )
                res = await db.users.insert_one(new_client.model_dump(by_alias=True, exclude=["id"]))
                assigned_ids.append(str(res.inserted_id))
    
    event_data['assignedUsers'] = list(set(event_data.get('assignedUsers', []) + assigned_ids))
    
    # 2. Defaults
    if not event_data.get('subEvents'):
        event_data['subEvents'] = [
            SubEvent(id=f"se-{int(time.time())}", name="Main Event", date=event.date).model_dump()
        ]

    # 3. Save
    res = await db.events.insert_one(event_data)
    
    # 4. Update Stats for Photographer
    await db.users.update_one(
        {"_id": ObjectId(event.photographerId)}, 
        {"$inc": {"totalEventsCount": 1, "totalUsersCount": len(assigned_ids)}}
    )

    return await db.events.find_one({"_id": res.inserted_id})

@app.put("/api/events/{id}", response_model=Event)
async def update_event(id: str, updates: dict = Body(...)):
    if '_id' in updates: del updates['_id']
    await db.events.update_one({"_id": ObjectId(id)}, {"$set": updates})
    return await db.events.find_one({"_id": ObjectId(id)})

@app.post("/api/events/{id}/team", response_model=Event)
async def add_team_member(id: str, req: AddTeamMemberRequest):
    # 1. Check if user exists or create
    user = await db.users.find_one({"email": req.email})
    if not user:
        user_name = req.email.split('@')[0]
        new_user = User(
            email=req.email,
            name=user_name,
            role='PHOTOGRAPHER',
            avatar=f"https://ui-avatars.com/api/?name={user_name}&background=random"
        )
        res = await db.users.insert_one(new_user.model_dump(by_alias=True, exclude=["id"]))
        user = await db.users.find_one({"_id": res.inserted_id})
    
    user_id = str(user["_id"])
    
    # 2. Update Event Team
    # Check if already in team
    event = await db.events.find_one({"_id": ObjectId(id)})
    team = event.get('team', [])
    
    if not any(m['userId'] == user_id for m in team):
        new_member = {"userId": user_id, "role": req.role}
        await db.events.update_one(
            {"_id": ObjectId(id)},
            {"$push": {"team": new_member}}
        )
    
    return await db.events.find_one({"_id": ObjectId(id)})

@app.delete("/api/events/{id}/team/{user_id}", response_model=Event)
async def remove_team_member(id: str, user_id: str):
    await db.events.update_one(
        {"_id": ObjectId(id)},
        {"$pull": {"team": {"userId": user_id}}}
    )
    return await db.events.find_one({"_id": ObjectId(id)})

@app.post("/api/events/{id}/submit-selections")
async def submit_selections(id: str):
    await db.events.update_one(
        {"_id": ObjectId(id)}, 
        {"$set": {
            "selectionStatus": "submitted", 
            "timeline.selectionSubmittedAt": datetime.now()
        }}
    )
    return {"message": "Submitted"}

@app.post("/api/events/{id}/payment", response_model=Event)
async def record_payment(id: str, payment: PaymentRequest):
    event = await db.events.find_one({"_id": ObjectId(id)})
    if not event: raise HTTPException(404, "Event not found")
    
    new_record = PaymentRecord(
        id=f"pay-{int(time.time())}",
        date=datetime.fromisoformat(payment.date.replace('Z', '+00:00')),
        amount=payment.amount,
        method=payment.method,
        note=payment.note
    )
    
    new_paid_amount = (event.get('paidAmount') or 0) + payment.amount
    payment_status = 'paid' if new_paid_amount >= (event.get('price') or 0) else 'partial'
    
    await db.events.update_one(
        {"_id": ObjectId(id)}, 
        {
            "$push": {"paymentHistory": new_record.model_dump()},
            "$set": {
                "paidAmount": new_paid_amount,
                "paymentStatus": payment_status
            }
        }
    )
    return await db.events.find_one({"_id": ObjectId(id)})

# --- Photos ---

@app.get("/api/events/{id}/photos", response_model=List[Photo])
async def get_event_photos(id: str):
    return await db.photos.find({"eventId": id}).to_list(5000)

@app.post("/api/events/{id}/photos", response_model=List[Photo])
async def add_photos_metadata(id: str, payload: PhotoUploadRequest, background_tasks: BackgroundTasks):
    photos_data = []
    for p in payload.photos:
        p_dict = p.model_dump(by_alias=True, exclude=["id"])
        p_dict['eventId'] = id
        p_dict['isAiProcessed'] = False
        photos_data.append(p_dict)
        
    if not photos_data: return []
    
    res = await db.photos.insert_many(photos_data)
    
    # Update count
    count = await db.photos.count_documents({"eventId": id})
    await db.events.update_one({"_id": ObjectId(id)}, {"$set": {"photoCount": count}})
    
    # Update Photographer Stats
    evt = await db.events.find_one({"_id": ObjectId(id)})
    if evt:
        await db.users.update_one(
            {"_id": ObjectId(evt['photographerId'])}, 
            {"$inc": {"totalPhotosCount": len(photos_data)}}
        )

    # Trigger AI
    background_tasks.add_task(trigger_ai_service, id)
    
    # Return created
    return await db.photos.find({"_id": {"$in": res.inserted_ids}}).to_list(None)

@app.post("/api/photos/{id}/selection", response_model=Photo)
async def toggle_selection(id: str):
    photo = await db.photos.find_one({"_id": ObjectId(id)})
    if not photo: raise HTTPException(404, "Not found")
    
    new_val = not photo.get('isSelected', False)
    await db.photos.update_one({"_id": ObjectId(id)}, {"$set": {"isSelected": new_val}})
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.put("/api/photos/{id}", response_model=Photo)
async def update_photo(id: str, updates: dict = Body(...)):
    if '_id' in updates: del updates['_id']
    await db.photos.update_one({"_id": ObjectId(id)}, {"$set": updates})
    return await db.photos.find_one({"_id": ObjectId(id)})

@app.delete("/api/photos/{id}")
async def delete_photo(id: str):
    photo = await db.photos.find_one({"_id": ObjectId(id)})
    if photo:
        await db.photos.delete_one({"_id": ObjectId(id)})
        # Ideally delete physical file too, skipping for demo
        count = await db.photos.count_documents({"eventId": photo['eventId']})
        await db.events.update_one({"_id": ObjectId(photo['eventId'])}, {"$set": {"photoCount": count}})
    return {"message": "Deleted"}

if __name__ == "__main__":
    import uvicorn
    # Updated Port to 8010
    uvicorn.run(app, host="0.0.0.0", port=8010)
