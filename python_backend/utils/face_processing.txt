
import os
import cv2
import numpy as np
from deepface import DeepFace
import chromadb
from chromadb.config import Settings
import uuid
from typing import List, Tuple, Dict
from PIL import Image

# Setup ChromaDB
CHROMA_DB_DIR = "chroma_db"
os.makedirs(CHROMA_DB_DIR, exist_ok=True)
chroma_client = chromadb.PersistentClient(path=CHROMA_DB_DIR)

class FaceService:
    def __init__(self, upload_dir="uploads"):
        self.upload_dir = upload_dir
        self.faces_dir = os.path.join(upload_dir, "faces")
        os.makedirs(self.faces_dir, exist_ok=True)

    def get_collection(self, event_id: str):
        """Get or create a vector collection for the specific event."""
        # Chroma collection names must be short and alphanumeric
        safe_name = f"evt_{event_id}"[-63:] 
        return chroma_client.get_or_create_collection(name=safe_name, metadata={"hnsw:space": "cosine"})

    def process_image(self, image_path: str, event_id: str) -> Tuple[List[str], bool]:
        """
        Detects faces, generates embeddings, clusters them, and returns person names.
        Returns: (List of Names, IsHighQualityFacePresent)
        """
        full_path = os.path.join(self.upload_dir, image_path.lstrip('/'))
        if not os.path.exists(full_path):
            print(f"Image not found: {full_path}")
            return [], False

        try:
            # DeepFace.represent returns a list of dictionaries
            # Each dict: {'embedding': [...], 'facial_area': {'x':, 'y':, 'w':, 'h':}, 'face_confidence': ...}
            # We use "Facenet512" for high accuracy embeddings (512 dimensions)
            # We use "opencv" detector for speed and CPU compatibility (no dlib required)
            # enforce_detection=True skips images with no faces (raises ValueError)
            faces = DeepFace.represent(
                img_path=full_path, 
                model_name="Facenet512", 
                detector_backend="opencv", 
                enforce_detection=True,
                align=True
            )
        except ValueError:
            # No face detected
            return [], False
        except Exception as e:
            print(f"DeepFace processing error: {e}")
            return [], False

        collection = self.get_collection(event_id)
        identified_people = []
        high_quality = False

        # Process each face found
        for face_obj in faces:
            embedding = face_obj['embedding']
            area = face_obj['facial_area']
            confidence = face_obj.get('face_confidence', 0)

            # Basic quality check based on resolution
            if area['w'] > 80 and area['h'] > 80:
                high_quality = True

            # Query Vector DB
            # ChromaDB expects list of lists for embeddings
            results = collection.query(
                query_embeddings=[embedding],
                n_results=1
            )

            person_name = None
            
            # Check distance threshold (Cosine distance)
            # For Facenet512, a threshold around 0.4 - 0.5 is usually good for DeepFace
            if results['ids'] and results['ids'][0] and results['distances'] and results['distances'][0]:
                distance = results['distances'][0][0]
                if distance < 0.4: # Match threshold
                    person_name = results['metadatas'][0][0]['name']

            # If new person
            if not person_name:
                person_id = str(uuid.uuid4())
                existing_count = collection.count()
                person_name = f"Person {existing_count + 1}"
                
                # Save Thumbnail (Needs original image to crop)
                # Load image with PIL to crop, safer than cv2 for file operations
                try:
                    thumb_url = self._save_face_thumbnail(full_path, area, event_id, person_name)
                except Exception as e:
                    print(f"Thumbnail save failed: {e}")
                    thumb_url = ""
                
                # Add to Vector DB
                collection.add(
                    documents=[person_name],
                    embeddings=[embedding],
                    metadatas=[{"name": person_name, "thumbnail": thumb_url}],
                    ids=[person_id]
                )
                
            identified_people.append(person_name)

        return list(set(identified_people)), high_quality

    def _save_face_thumbnail(self, image_full_path, area, event_id, person_name):
        """Crops face and saves to disk using DeepFace coordinates."""
        x, y, w, h = area['x'], area['y'], area['w'], area['h']
        
        with Image.open(image_full_path) as img:
            width, height = img.size
            
            # Add padding (20%)
            pad_w = int(w * 0.2)
            pad_h = int(h * 0.2)
            
            left = max(0, x - pad_w)
            top = max(0, y - pad_h)
            right = min(width, x + w + pad_w)
            bottom = min(height, y + h + pad_h)
            
            face_crop = img.crop((left, top, right, bottom))
            
            # Directory
            event_face_dir = os.path.join(self.faces_dir, event_id)
            os.makedirs(event_face_dir, exist_ok=True)
            
            # Sanitize filename
            safe_name = "".join([c for c in person_name if c.isalnum() or c in (' ', '-', '_')]).strip()
            filename = f"{safe_name}.jpg"
            save_path = os.path.join(event_face_dir, filename)
            
            face_crop.save(save_path)
            
            return f"/uploads/faces/{event_id}/{filename}"

    def get_event_faces(self, event_id: str) -> Dict[str, str]:
        """Retrieve all known faces (Name -> Thumbnail) for an event from ChromaDB metadata."""
        collection = self.get_collection(event_id)
        if collection.count() == 0:
            return {}
            
        data = collection.get(include=['metadatas'])
        faces_map = {}
        if data['metadatas']:
            for meta in data['metadatas']:
                if meta:
                    faces_map[meta['name']] = meta.get('thumbnail', '')
        return faces_map
