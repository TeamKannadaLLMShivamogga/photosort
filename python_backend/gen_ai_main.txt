
import os
import asyncio
import random
from typing import Optional, List, Dict

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
from motor.motor_asyncio import AsyncIOMotorClient
from bson import ObjectId
from dotenv import load_dotenv

# Import our new service
from .utils.face_processing import FaceService

load_dotenv()

MONGO_URL = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
DB_NAME = "photosort"
UPLOAD_DIR = "uploads"

client = AsyncIOMotorClient(MONGO_URL)
db = client[DB_NAME]

app = FastAPI()
face_service = FaceService(upload_dir=UPLOAD_DIR)

class ProcessEventRequest(BaseModel):
    force_reprocess: bool = False

class AiProcessResponse(BaseModel):
    message: str
    event_id: str
    tasks_queued: int

# --- Logic ---

async def run_ai_processing(event_id: str):
    print(f"AI Service: Starting processing for {event_id}")
    
    # 1. Fetch Context
    event = await db.events.find_one({"_id": ObjectId(event_id)})
    if not event:
        print(f"Event {event_id} not found")
        return

    # 2. Fetch Unprocessed
    cursor = db.photos.find({"eventId": event_id, "isAiProcessed": False})
    photos = await cursor.to_list(None)
    
    print(f"AI Service: Processing {len(photos)} images...")

    tags_pool = ["Happy", "Candid", "Decor", "Dance", "Food", "Group", "Portrait", "Ritual", "Outdoors"]

    for photo in photos:
        # Process Face Recognition
        # This is a blocking CPU operation, usually handled by a worker queue (Celery). 
        # For this simple backend, we run it directly in the loop.
        try:
            detected_people, has_quality_face = face_service.process_image(photo['url'], event_id)
        except Exception as e:
            print(f"Face processing failed for {photo['_id']}: {e}")
            detected_people = []
            has_quality_face = False

        # --- Metadata Generation ---
        
        # A. Category (Sub-event classification)
        category = "General"
        if event.get('subEvents'):
            # Simple timestamp matching could go here, or random for demo
            category = random.choice(event["subEvents"])["name"]

        # B. Tags
        tags = []
        if has_quality_face:
            tags.append("Portrait")
        if len(detected_people) > 2:
            tags.append("Group")
        
        # Random filler tags for demo vibrancy
        tags.extend(random.sample(tags_pool, k=random.randint(1, 2)))
        
        # C. Quality Score (AI Pick)
        # Real logic: if image is sharp and has a high-quality face found
        is_ai_pick = has_quality_face and random.random() > 0.3
        quality = 'high' if is_ai_pick else 'medium'

        # 4. Update Photo in DB
        update_fields = {
            "isAiProcessed": True,
            "category": category,
            "tags": list(set(tags)),
            "people": detected_people,
            "isAiPick": is_ai_pick,
            "quality": quality
        }

        await db.photos.update_one(
            {"_id": photo["_id"]},
            {"$set": update_fields}
        )
    
    # 5. Sync Face Registry to Event
    # This ensures the UI has a map of "Person 1" -> "Thumbnail URL"
    all_faces = face_service.get_event_faces(event_id)
    if all_faces:
        await db.events.update_one(
            {"_id": ObjectId(event_id)},
            {"$set": {"faces": all_faces}}
        )

    print(f"AI Service: Completed {event_id}")

# --- Routes ---

@app.get("/health")
def health_check():
    return {"status": "ok", "mode": "Active Inference (dlib/chroma)"}

@app.post("/process-event/{event_id}", response_model=AiProcessResponse)
async def process_event(event_id: str, background_tasks: BackgroundTasks):
    count = await db.photos.count_documents({"eventId": event_id, "isAiProcessed": False})
    background_tasks.add_task(run_ai_processing, event_id)
    return AiProcessResponse(message="Queued", event_id=event_id, tasks_queued=count)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
