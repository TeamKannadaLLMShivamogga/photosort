import os
import asyncio
import random
from typing import Optional, List, Dict

from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
from motor.motor_asyncio import AsyncIOMotorClient
from bson import ObjectId
from dotenv import load_dotenv

load_dotenv()

MONGO_URL = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
DB_NAME = "photosort"

client = AsyncIOMotorClient(MONGO_URL)
db = client[DB_NAME]

app = FastAPI()

class ProcessEventRequest(BaseModel):
    force_reprocess: bool = False

class AiProcessResponse(BaseModel):
    message: str
    event_id: str
    tasks_queued: int

# --- Simulation Logic ---

async def run_ai_processing(event_id: str):
    print(f"AI Service: Starting processing for {event_id}")
    
    # 1. Fetch Context
    event = await db.events.find_one({"_id": ObjectId(event_id)})
    if not event:
        return

    # Fetch Clients for Face ID Simulation
    clients = []
    for uid in event.get('assignedUsers', []):
        u = await db.users.find_one({"_id": ObjectId(uid)})
        if u: clients.append(u['name'].split()[0]) # Just take first name

    sub_events = event.get('subEvents', [])
    sub_event_names = [se['name'] for se in sub_events] if sub_events else ['Main Event']

    # 2. Fetch Unprocessed
    cursor = db.photos.find({"eventId": event_id, "isAiProcessed": False})
    photos = await cursor.to_list(None)
    
    print(f"AI Service: Processing {len(photos)} images...")

    tags_pool = ["Happy", "Candid", "Decor", "Dance", "Food", "Group", "Portrait", "Ritual", "Outdoors", "Black & White"]

    for photo in photos:
        # Artifical delay to simulate GPU work
        await asyncio.sleep(0.05) 
        
        # 3. Generate Metadata
        
        # A. Category (Sub-event classification)
        # Randomly assign to a sub-event if available, else 'General'
        category = random.choice(sub_event_names) if sub_event_names else "General"
        sub_event_id = next((se['id'] for se in sub_events if se['name'] == category), None)

        # B. Tags
        num_tags = random.randint(2, 5)
        tags = random.sample(tags_pool, num_tags)
        
        # C. People (Face Clustering)
        # Randomly find 0-3 people from the client list
        detected_people = []
        if clients:
            # 70% chance of finding at least one person
            if random.random() < 0.7:
                count = random.randint(1, min(3, len(clients)))
                detected_people = random.sample(clients, count)
        
        # D. Quality Score (AI Pick)
        # 20% chance of being a 'Highlight'
        is_ai_pick = random.random() < 0.2
        quality = 'high' if is_ai_pick else random.choice(['medium', 'medium', 'low'])

        # 4. Update DB
        update_fields = {
            "isAiProcessed": True,
            "category": category,
            "subEventId": sub_event_id,
            "tags": tags,
            "people": detected_people,
            "isAiPick": is_ai_pick,
            "quality": quality
        }

        await db.photos.update_one(
            {"_id": photo["_id"]},
            {"$set": update_fields}
        )
    
    print(f"AI Service: Completed {event_id}")

# --- Routes ---

@app.get("/health")
def health_check():
    return {"status": "ok", "mode": "Mock Inference"}

@app.post("/process-event/{event_id}", response_model=AiProcessResponse)
async def process_event(event_id: str, background_tasks: BackgroundTasks):
    count = await db.photos.count_documents({"eventId": event_id, "isAiProcessed": False})
    background_tasks.add_task(run_ai_processing, event_id)
    return AiProcessResponse(message="Queued", event_id=event_id, tasks_queued=count)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
